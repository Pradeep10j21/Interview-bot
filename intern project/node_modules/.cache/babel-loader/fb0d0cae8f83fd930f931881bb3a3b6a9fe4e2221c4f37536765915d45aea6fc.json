{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef } from 'react';\nexport function useSpeechToText() {\n  _s();\n  const [transcript, setTranscript] = useState('');\n  const [isListening, setIsListening] = useState(false);\n  const recognitionRef = useRef(null);\n  useEffect(() => {\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n    if (!SpeechRecognition) {\n      console.warn('Speech Recognition API not supported in this browser');\n      return;\n    }\n    const recognition = new SpeechRecognition();\n    recognition.continuous = true;\n    recognition.interimResults = true;\n    recognition.lang = 'en-US';\n    recognition.maxAlternatives = 1;\n\n    // Optimize for speed - process results faster\n    if (recognition.grammars) {\n      recognition.grammars = null; // Disable grammars for faster processing\n    }\n    recognition.onresult = event => {\n      let interimTranscript = '';\n      let finalTranscript = '';\n\n      // Process all results for faster updates\n      for (let i = 0; i < event.results.length; i++) {\n        const result = event.results[i];\n        const transcript = result[0].transcript;\n        const confidence = result[0].confidence || 0.7;\n\n        // Lower confidence threshold for faster updates\n        if (confidence > 0.3) {\n          if (result.isFinal) {\n            finalTranscript += transcript + ' ';\n          } else {\n            // Show interim results immediately for faster feedback\n            interimTranscript += transcript;\n          }\n        }\n      }\n\n      // Combine final and interim - show interim immediately for speed\n      const combined = finalTranscript.trim() + (interimTranscript ? ' ' + interimTranscript : '');\n      // Update immediately without checking length for faster response\n      setTranscript(combined);\n    };\n    recognition.onerror = event => {\n      console.error('Speech recognition error:', event.error);\n      if (event.error === 'no-speech') {\n        setIsListening(false);\n      }\n    };\n    recognition.onend = () => {\n      setIsListening(false);\n      // Auto-restart if continuous mode is enabled\n      // Only restart if we're still supposed to be listening\n      if (recognitionRef.current) {\n        const shouldRestart = recognitionRef.current.continuous;\n        if (shouldRestart) {\n          // Reduced delay for faster restart\n          setTimeout(() => {\n            try {\n              if (recognitionRef.current) {\n                recognitionRef.current.start();\n                setIsListening(true);\n              }\n            } catch (error) {\n              // Ignore errors when restarting (might already be started)\n            }\n          }, 50);\n        }\n      }\n    };\n    recognitionRef.current = recognition;\n    return () => {\n      if (recognitionRef.current) {\n        recognitionRef.current.stop();\n      }\n    };\n  }, []);\n  const startListening = () => {\n    if (recognitionRef.current && !isListening) {\n      try {\n        recognitionRef.current.start();\n        setIsListening(true);\n      } catch (error) {\n        console.error('Error starting recognition:', error);\n      }\n    }\n  };\n  const stopListening = () => {\n    if (recognitionRef.current && isListening) {\n      recognitionRef.current.stop();\n      setIsListening(false);\n    }\n  };\n  const resetTranscript = () => {\n    setTranscript('');\n  };\n  return {\n    transcript,\n    isListening,\n    startListening,\n    stopListening,\n    resetTranscript\n  };\n}\n_s(useSpeechToText, \"vnCmTUEDbQBVF/ADb+daLPbEqzg=\");","map":{"version":3,"names":["useState","useEffect","useRef","useSpeechToText","_s","transcript","setTranscript","isListening","setIsListening","recognitionRef","SpeechRecognition","window","webkitSpeechRecognition","console","warn","recognition","continuous","interimResults","lang","maxAlternatives","grammars","onresult","event","interimTranscript","finalTranscript","i","results","length","result","confidence","isFinal","combined","trim","onerror","error","onend","current","shouldRestart","setTimeout","start","stop","startListening","stopListening","resetTranscript"],"sources":["C:/Users/DEll india/OneDrive/Desktop/intern project/src/hooks/useSpeechToText.js"],"sourcesContent":["import { useState, useEffect, useRef } from 'react';\r\n\r\nexport function useSpeechToText() {\r\n  const [transcript, setTranscript] = useState('');\r\n  const [isListening, setIsListening] = useState(false);\r\n  const recognitionRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\r\n    \r\n    if (!SpeechRecognition) {\r\n      console.warn('Speech Recognition API not supported in this browser');\r\n      return;\r\n    }\r\n\r\n    const recognition = new SpeechRecognition();\r\n    recognition.continuous = true;\r\n    recognition.interimResults = true;\r\n    recognition.lang = 'en-US';\r\n    recognition.maxAlternatives = 1;\r\n    \r\n    // Optimize for speed - process results faster\r\n    if (recognition.grammars) {\r\n      recognition.grammars = null; // Disable grammars for faster processing\r\n    }\r\n\r\n    recognition.onresult = (event) => {\r\n      let interimTranscript = '';\r\n      let finalTranscript = '';\r\n\r\n      // Process all results for faster updates\r\n      for (let i = 0; i < event.results.length; i++) {\r\n        const result = event.results[i];\r\n        const transcript = result[0].transcript;\r\n        const confidence = result[0].confidence || 0.7;\r\n        \r\n        // Lower confidence threshold for faster updates\r\n        if (confidence > 0.3) {\r\n          if (result.isFinal) {\r\n            finalTranscript += transcript + ' ';\r\n          } else {\r\n            // Show interim results immediately for faster feedback\r\n            interimTranscript += transcript;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Combine final and interim - show interim immediately for speed\r\n      const combined = finalTranscript.trim() + (interimTranscript ? ' ' + interimTranscript : '');\r\n      // Update immediately without checking length for faster response\r\n      setTranscript(combined);\r\n    };\r\n\r\n    recognition.onerror = (event) => {\r\n      console.error('Speech recognition error:', event.error);\r\n      if (event.error === 'no-speech') {\r\n        setIsListening(false);\r\n      }\r\n    };\r\n\r\n    recognition.onend = () => {\r\n      setIsListening(false);\r\n      // Auto-restart if continuous mode is enabled\r\n      // Only restart if we're still supposed to be listening\r\n      if (recognitionRef.current) {\r\n        const shouldRestart = recognitionRef.current.continuous;\r\n        if (shouldRestart) {\r\n          // Reduced delay for faster restart\r\n          setTimeout(() => {\r\n            try {\r\n              if (recognitionRef.current) {\r\n                recognitionRef.current.start();\r\n                setIsListening(true);\r\n              }\r\n            } catch (error) {\r\n              // Ignore errors when restarting (might already be started)\r\n            }\r\n          }, 50);\r\n        }\r\n      }\r\n    };\r\n\r\n    recognitionRef.current = recognition;\r\n\r\n    return () => {\r\n      if (recognitionRef.current) {\r\n        recognitionRef.current.stop();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const startListening = () => {\r\n    if (recognitionRef.current && !isListening) {\r\n      try {\r\n        recognitionRef.current.start();\r\n        setIsListening(true);\r\n      } catch (error) {\r\n        console.error('Error starting recognition:', error);\r\n      }\r\n    }\r\n  };\r\n\r\n  const stopListening = () => {\r\n    if (recognitionRef.current && isListening) {\r\n      recognitionRef.current.stop();\r\n      setIsListening(false);\r\n    }\r\n  };\r\n\r\n  const resetTranscript = () => {\r\n    setTranscript('');\r\n  };\r\n\r\n  return {\r\n    transcript,\r\n    isListening,\r\n    startListening,\r\n    stopListening,\r\n    resetTranscript\r\n  };\r\n}\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}